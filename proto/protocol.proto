syntax = "proto2";
package msgs;

import "keys.proto";

message KeystrokeRequest {
  required uint64 app_id = 1;
  required bool ctrl  = 2;
  required bool alt   = 3;
  required bool shift = 4;
  required bool meta  = 5;
  required Keycode key = 6;
}

message AppList {
  repeated Application apps = 1;
}

message Application {
    required uint64 id = 1;
    required string name = 2;
	optional Icon icon = 3;
}

message Icon {
	// Size in pixels
	required uint32 width = 1;
	required uint32 height = 2;
	// Raw image data, in packed RGBA32 format
	// < r: u8, g: u8, b: u8, a: u8 >
	// `pixels` should be (width * height * 4) bytes
	required bytes pixels = 3;
}

message AppDestroyed {
    required uint64 id = 1;
}

message AppGotFocus {
    required uint64 id = 1;
}

// in a case like this, one would normally use a `tagged union', also known as
// a `Type-Length-Value' encoding in network protocol jargon, but it turns out
// that a message composed of all `optional' fields is encoded by Protobuf in
// much the same way (and just as efficiently) as a sequence of TLV messages.
// See: https://developers.google.com/protocol-buffers/docs/encoding#optional
message Event {
    optional AppDestroyed destroyed = 1;
    optional Application  created = 2;
    optional AppGotFocus  got_focus = 3;
}
